package iqiyi

import (
	"testing"
	"time"
)

func TestGetM3u8(t *testing.T) {
	/*str, err := GetM3u8("http://www.iqiyi.com/v_19rro1vd70.html")
	if err != nil {
		t.Errorf("GetM3u8 error: %s", err)
	}
	t.Log(str)*/
	dict := []byte{63, 121, 172, 54, 86, 196, 114, 15, 108, 94, 77, 143, 89, 46, 209, 4, 242, 69, 216, 207, 154, 91, 50, 147, 165, 38, 27, 208, 7, 32, 192, 255, 169, 27, 177, 217, 3, 42, 52, 29, 86, 122, 6, 163, 238, 129, 185, 41, 52, 141, 201, 10, 48, 49, 92, 117, 67, 72, 45, 121, 93, 191, 101, 218, 73, 108, 157, 219, 7, 46, 238, 85, 81, 67, 83, 113, 67, 9, 185, 116, 230, 154, 15, 92, 142, 219, 90, 56, 204, 18, 1, 57, 95, 129, 83, 67, 212, 52, 117, 221, 86, 116, 186, 120, 240, 70, 216, 251, 173, 250, 10, 38, 39, 138, 188, 242, 93, 31, 25, 1, 248, 249, 194, 168, 74, 197, 83, 101, 214, 107, 121, 134, 109, 50, 111, 161, 62, 27, 191, 161, 1, 52, 81, 83, 109, 187, 122, 11, 185, 203, 34, 58, 38, 203, 243, 62, 174, 7, 242, 188, 148, 55, 4, 235, 238, 190, 103, 149, 40, 56, 190, 238, 219, 192, 53, 197, 123, 215, 66, 195, 57, 91, 74, 82, 13, 14, 109, 205, 236, 156, 206, 103, 213, 165, 175, 161, 161, 97, 231, 102, 224, 206, 244, 57, 55, 91, 20, 80, 194, 210, 205, 206, 39, 191, 19, 12, 130, 93, 160, 65, 153, 89, 104, 179, 230, 76, 196, 214, 218, 121, 39, 211, 246, 230, 110, 113, 131, 151, 52, 199, 144, 149, 72, 227, 214, 248, 144, 2, 114, 72, 178, 56, 73, 184, 117, 0}
	str := []byte("6f3ded0234eb056808331b883a1cc372ec2f98d8ab08069a924f59dc654d8e098d5ca3d259500474002c549addbc8e066494d83265581e0f217b7b0004f3309f001986f0734bc56c7334266a1a1040ec37f09e3e3f9fd27168f75463686fad1115e97217c21e26f61bd429dec9e0e239425ec2bcc1095e284de5c9c8ba19826107983a0f992a4a07ba6d23f59055792b1d39800f68f5dd125871c2a266e33ee1a1860735dbc58754b21a61f7cbdfa34de111ef28f26e167a0a5b3e46e3d7dd8304c6acfa9cb519a907f8e0ff63636f2c19e8daf7e06287465da82b8e28d02304a0ad7bd3c2c44c43f5deae563dcebb44ddb79324cdcde7c8581f71b75a1e8e456b3eb84c32f84637250839b50b6be951df13dedc89125480ae6f4dd45f74f4479b2995d160470575323f7eadf1cc96027799cf5f67671e3313237f3308aa33e21f2894d35168fe0452057718210550ec37f09e590c98d2326f845c446809ad11149e5c45c71e35f034e97fc2dcaab3384770a4a8ec242b614edcc68f9427f52507f95300b729775e927a42b6916b71651e07800c4690f34b745ce7e170b85ebc89b87230cca09b55b2427db8dff19a58e12ffb2ff053163d1d59695dfdd08fc405fce2e3be8834ef2bcaf3f4776463631efd96cbfc64f86741941c980fb3185880ce1eeef9f0236cfce6f23e20cda77eeca5807bc9ffffc24e4078b7750d8d44723d854e18fa34453a353db20e6b9640df75c4e3b50f56a38f6242c56578814f872881de537e7a790e2e32e5dece92027799c07c665b683e130b142a0da60a9b")
	for m := 0; m < 256; m++ {
		dict[255] = byte(m)
		result := make([]byte, len(str))
		for i, b := range str {
			result[i] = b ^ dict[i%256]
		}
		//t.Log(base64.StdEncoding.Decode(str, result))
		t.Log(m, string(result), "\n")
		time.Sleep(time.Millisecond * 10)
	}
}
